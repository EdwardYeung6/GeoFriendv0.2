Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"com.geofriend.geofriend\">\r\n    <!--\r\n         The ACCESS_COARSE/FINE_LOCATION permissions are not required to use\r\n         Google Maps Android API v2, but you must specify either coarse or fine\r\n         location permissions for the \"MyLocation\" functionality.\r\n    -->\r\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\r\n    <!--         The INTERNET/ACCESS_FINE_LOCATION permissions are required to get users current location. -->\r\n    <uses-permission android:name=\"android.permission.INTERNET\" />\r\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\r\n    <!--\r\n         The ACCESS_BACKGROUND_LOCATION permissions An app requires background location access\r\n         if a feature within the app constantly shares location with other users or uses the Geofencing API.\r\n         On Android 10 (API level 29) and higher, you must declare this explicitly!\r\n    -->\r\n    <uses-permission android:name=\"android.permission.ACCESS_BACKGROUND_LOCATION\" />\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/AppTheme\">\r\n        <activity android:name=\".getUserLocationDetails\"></activity>\r\n        <!--\r\n             The API key for Google Maps-based APIs is defined as a string resource.\r\n             (See the file \"res/values/google_maps_api.xml\").\r\n             Note that the API key is linked to the encryption key used to sign the APK.\r\n             You need a different API key for each encryption key, including the release key that is used to\r\n             sign the APK for publishing.\r\n             You can define the keys for the debug and release targets in src/debug/ and src/release/.\r\n        -->\r\n        <meta-data\r\n            android:name=\"com.google.android.geo.API_KEY\"\r\n            android:value=\"@string/google_maps_key\" />\r\n        <meta-data\r\n            android:name=\"preloaded_fonts\"\r\n            android:resource=\"@array/preloaded_fonts\" />\r\n\r\n        <activity\r\n            android:name=\".CurrentLocation\"\r\n            android:screenOrientation=\"portrait\"></activity>\r\n        <activity\r\n            android:name=\".LandmarkPopUpActivity\"\r\n            android:screenOrientation=\"portrait\"\r\n            android:theme=\"@style/AppTheme.LandmarkTheme\"></activity>\r\n        <activity\r\n            android:name=\".MapsActivity\"\r\n            android:label=\"@string/title_activity_maps\"\r\n            android:screenOrientation=\"portrait\" />\r\n        <activity\r\n            android:name=\".LoginActivity\"\r\n            android:screenOrientation=\"portrait\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity>\r\n\r\n        <service android:name=\".GetAddressIntentService\" />\r\n\r\n        <activity android:name=\".activity_adddata\" />\r\n    </application>\r\n\r\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/AndroidManifest.xml	(revision 08b08703bf179a5d47f20329c090f7eadc5ada2f)
+++ app/src/main/AndroidManifest.xml	(date 1605163776386)
@@ -1,21 +1,12 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.geofriend.geofriend">
+
     <!--
          The ACCESS_COARSE/FINE_LOCATION permissions are not required to use
          Google Maps Android API v2, but you must specify either coarse or fine
          location permissions for the "MyLocation" functionality.
     -->
-    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
-    <!--         The INTERNET/ACCESS_FINE_LOCATION permissions are required to get users current location. -->
-    <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
-    <!--
-         The ACCESS_BACKGROUND_LOCATION permissions An app requires background location access
-         if a feature within the app constantly shares location with other users or uses the Geofencing API.
-         On Android 10 (API level 29) and higher, you must declare this explicitly!
-    -->
-    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
 
     <application
         android:allowBackup="true"
@@ -24,7 +15,7 @@
         android:roundIcon="@mipmap/ic_launcher_round"
         android:supportsRtl="true"
         android:theme="@style/AppTheme">
-        <activity android:name=".getUserLocationDetails"></activity>
+
         <!--
              The API key for Google Maps-based APIs is defined as a string resource.
              (See the file "res/values/google_maps_api.xml").
@@ -33,20 +24,23 @@
              sign the APK for publishing.
              You can define the keys for the debug and release targets in src/debug/ and src/release/.
         -->
-        <meta-data
-            android:name="com.google.android.geo.API_KEY"
-            android:value="@string/google_maps_key" />
-        <meta-data
-            android:name="preloaded_fonts"
-            android:resource="@array/preloaded_fonts" />
 
+        <activity android:name=".getUserLocationDetails" />
         <activity
             android:name=".CurrentLocation"
-            android:screenOrientation="portrait"></activity>
+            android:screenOrientation="portrait" />
         <activity
             android:name=".LandmarkPopUpActivity"
             android:screenOrientation="portrait"
-            android:theme="@style/AppTheme.LandmarkTheme"></activity>
+            android:theme="@style/AppTheme.LandmarkTheme" />
+        <!--
+             The API key for Google Maps-based APIs is defined as a string resource.
+             (See the file "res/values/google_maps_api.xml").
+             Note that the API key is linked to the encryption key used to sign the APK.
+             You need a different API key for each encryption key, including the release key that is used to
+             sign the APK for publishing.
+             You can define the keys for the debug and release targets in src/debug/ and src/release/.
+        -->
         <activity
             android:name=".MapsActivity"
             android:label="@string/title_activity_maps"
@@ -60,10 +54,33 @@
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
-
-        <service android:name=".GetAddressIntentService" />
-
         <activity android:name=".activity_adddata" />
+        <meta-data
+            android:name="com.google.android.geo.API_KEY"
+            android:value="@string/google_maps_key" />
+
+        <meta-data
+            android:name="preloaded_fonts"
+            android:resource="@array/preloaded_fonts" />
+
+        <receiver
+            android:name=".GeofenceBoardCastReceiver"
+            android:enabled="true"
+            android:exported="true" />
+
+        <service android:name=".GetAddressIntentService" />
     </application>
 
+    <!-- The INTERNET/ACCESS_FINE_LOCATION permissions are required to get users current location. -->
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <!--
+         The ACCESS_BACKGROUND_LOCATION permissions An app requires background location access
+         if a feature within the app constantly shares location with other users or uses the Geofencing API.
+         On Android 10 (API level 29) and higher, you must declare this explicitly!
+    -->
+    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
+
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+
 </manifest>
\ No newline at end of file
Index: app/src/main/java/com/geofriend/geofriend/GeofenceBoardCastReceiver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/geofriend/geofriend/GeofenceBoardCastReceiver.java	(date 1605164554691)
+++ app/src/main/java/com/geofriend/geofriend/GeofenceBoardCastReceiver.java	(date 1605164554691)
@@ -0,0 +1,47 @@
+package com.geofriend.geofriend;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.AsyncTask;
+import android.util.Log;
+import android.widget.Toast;
+
+import com.google.android.gms.location.Geofence;
+import com.google.android.gms.location.GeofencingEvent;
+
+import java.util.List;
+
+public class GeofenceBoardCastReceiver extends BroadcastReceiver {
+
+    private static final String TAG = "GeofenceBroadcastReceiver";
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        // TODO: This method is called when the BroadcastReceiver is receiving
+        // an Intent broadcast.
+
+        //Toast.makeText(context, "Geofencing trigger", Toast.LENGTH_LONG).show();
+
+        GeofencingEvent geofencingEvent = GeofencingEvent.fromIntent((intent));
+        if(geofencingEvent.hasError()){
+            Log.d(TAG,"onRecieve:Error receivng geofenc event..");
+            return;
+        }
+        List<Geofence> geofenceList=geofencingEvent.getTriggeringGeofences();
+        //Location location = geofenceingEvent.getTriggerLocation();
+        for (Geofence geofence:geofenceList){
+            Log.d(TAG,"onReceive"+ geofence.getRequestId());
+        }
+        int transitionType=geofencingEvent.getGeofenceTransition();
+
+        switch (transitionType){
+            case Geofence.GEOFENCE_TRANSITION_ENTER:
+                Toast.makeText(context,"Geofenc Enter",Toast.LENGTH_SHORT).show();
+                break;
+            case Geofence.GEOFENCE_TRANSITION_EXIT:
+                Toast.makeText(context,"Geofenc exit",Toast.LENGTH_SHORT).show();
+                break;
+        }
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/geofriend/geofriend/LandmarkMapAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.geofriend.geofriend;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class LandmarkMapAdapter {\r\n\r\n    public static ArrayList<LandMark> landmarks = new ArrayList<LandMark>();\r\n\r\n    public LandmarkMapAdapter(){\r\n\r\n    }\r\n\r\n\r\n    //Put these into database and be able to access them\r\n    public void loadLandmarks(){\r\n        landmarks.add(0, new LandMark(1, \"Juniper Park\", 50.66107816, -120.2600196, \"A park in Juniper Ridge.\",R.drawable.image5));\r\n        landmarks.add(1, new LandMark(2, \"Juniper Dog Park\", 50.66165625, -120.26141435, \"A dog park in Juniper Ridge.\",R.drawable.image5));\r\n        landmarks.add(2, new LandMark(3, \"Juniper Roundabout\", 50.661075, -120.262175, \"A roundabout in Juniper Ridge.\",R.drawable.image5));\r\n        landmarks.add(3, new LandMark(4, \"TRU HOL\", 50.675940, -120.360050, \"Testing the description\", R.drawable.image1));\r\n        landmarks.add(4, new LandMark(5, \"Kamloops Downtown\", 52.675940, -124.360050, \"Testing... description\", R.drawable.image2));\r\n        landmarks.add(5, new LandMark(6, \"TRU HOL\", 48.675940, -118.360050, \"Testing ...\", R.drawable.image1));\r\n    }\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/geofriend/geofriend/LandmarkMapAdapter.java	(revision 08b08703bf179a5d47f20329c090f7eadc5ada2f)
+++ app/src/main/java/com/geofriend/geofriend/LandmarkMapAdapter.java	(date 1605159848239)
@@ -19,7 +19,8 @@
         landmarks.add(2, new LandMark(3, "Juniper Roundabout", 50.661075, -120.262175, "A roundabout in Juniper Ridge.",R.drawable.image5));
         landmarks.add(3, new LandMark(4, "TRU HOL", 50.675940, -120.360050, "Testing the description", R.drawable.image1));
         landmarks.add(4, new LandMark(5, "Kamloops Downtown", 52.675940, -124.360050, "Testing... description", R.drawable.image2));
-        landmarks.add(5, new LandMark(6, "TRU HOL", 48.675940, -118.360050, "Testing ...", R.drawable.image1));
+       // landmarks.add(5, new LandMark(6, "TRU HOL", 48.675940, -118.360050, "Testing ...", R.drawable.image1));
+        landmarks.add(5, new LandMark(6, "Edward Hone", 37.422, -122.084, "Testing ...", R.drawable.image1));
     }
 
 
Index: app/src/main/java/com/geofriend/geofriend/GeofenceHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.geofriend.geofriend;\r\n\r\nimport android.app.PendingIntent;\r\nimport android.content.Context;\r\nimport android.content.ContextWrapper;\r\n\r\nimport com.google.android.gms.location.Geofence;\r\nimport com.google.android.gms.location.GeofencingRequest;\r\nimport com.google.android.gms.maps.model.LatLng;\r\n\r\npublic class GeofenceHelper extends ContextWrapper {\r\nPendingIntent pendingIntent;\r\nprivate static final String TAG=\"GeoFencingHelper\";\r\n\r\n    public GeofenceHelper(Context base) {\r\n        super(base);\r\n    }\r\n\r\n    public GeofencingRequest geofencingRequest(Geofence geofence){\r\n        return null;\r\n    }\r\n\r\n    public Geofence getGeogfence(String ID, LatLng,float radius,int transitionTypes){\r\n        return null;\r\n    }\r\n\r\n\r\n    public PendingIntent getPendingIntent(){\r\n    return pendingIntent;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/geofriend/geofriend/GeofenceHelper.java	(revision 08b08703bf179a5d47f20329c090f7eadc5ada2f)
+++ app/src/main/java/com/geofriend/geofriend/GeofenceHelper.java	(date 1605160824920)
@@ -3,29 +3,59 @@
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.ContextWrapper;
+import android.content.Intent;
 
+import com.google.android.gms.common.api.ApiException;
 import com.google.android.gms.location.Geofence;
+import com.google.android.gms.location.GeofenceStatusCodes;
 import com.google.android.gms.location.GeofencingRequest;
 import com.google.android.gms.maps.model.LatLng;
 
 public class GeofenceHelper extends ContextWrapper {
-PendingIntent pendingIntent;
+    PendingIntent pendingIntent;
 private static final String TAG="GeoFencingHelper";
 
     public GeofenceHelper(Context base) {
         super(base);
     }
 
-    public GeofencingRequest geofencingRequest(Geofence geofence){
-        return null;
+    public static GeofencingRequest getGeofencingRequest(Geofence geofence){
+        return  new GeofencingRequest.Builder().addGeofence(geofence).setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER).build();
     }
 
-    public Geofence getGeogfence(String ID, LatLng,float radius,int transitionTypes){
-        return null;
+    public static Geofence getGeofence(String ID,LatLng latlng, float radius, int transitionTypes){
+        return new Geofence.Builder().setCircularRegion(latlng.latitude,latlng.longitude,radius).setRequestId(ID).setTransitionTypes(transitionTypes).setLoiteringDelay(5000).setExpirationDuration(Geofence.NEVER_EXPIRE).build();
+
     }
 
 
-    public PendingIntent getPendingIntent(){
-    return pendingIntent;
+    public PendingIntent getPendingIntent() {
+        if (pendingIntent != null) {
+            return pendingIntent;
+        }
+        Intent intent = new Intent(this, GeofenceBoardCastReceiver.class);
+        pendingIntent = PendingIntent.getBroadcast(this, 2607, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+
+        return pendingIntent;
     }
+
+    public static String getErrorString(Exception e){
+        if(e instanceof ApiException){
+            ApiException apiException=(ApiException ) e;
+            switch (apiException.getStatusCode()){
+                case GeofenceStatusCodes
+                        .GEOFENCE_NOT_AVAILABLE:
+                    return "Geofence not avaliavle";
+
+                case GeofenceStatusCodes
+                        .GEOFENCE_TOO_MANY_GEOFENCES:
+                    return "Geofence too many";
+
+                case GeofenceStatusCodes
+                        .GEOFENCE_TOO_MANY_PENDING_INTENTS:
+                    return "Too many pending";
+
+            }
+        }return e.getLocalizedMessage();
+    }
 }
Index: app/src/main/java/com/geofriend/geofriend/MapsActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.geofriend.geofriend;\r\n\r\nimport android.Manifest;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.graphics.Color;\r\nimport android.location.Location;\r\nimport android.os.Bundle;\r\nimport android.util.Log;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.core.app.ActivityCompat;\r\nimport androidx.core.content.ContextCompat;\r\nimport androidx.fragment.app.FragmentActivity;\r\n\r\nimport com.google.android.gms.location.FusedLocationProviderClient;\r\nimport com.google.android.gms.location.GeofencingClient;\r\nimport com.google.android.gms.location.LocationCallback;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.location.LocationResult;\r\nimport com.google.android.gms.location.LocationServices;\r\nimport com.google.android.gms.maps.CameraUpdateFactory;\r\nimport com.google.android.gms.maps.GoogleMap;\r\nimport com.google.android.gms.maps.OnMapReadyCallback;\r\nimport com.google.android.gms.maps.SupportMapFragment;\r\nimport com.google.android.gms.maps.model.CircleOptions;\r\nimport com.google.android.gms.maps.model.LatLng;\r\nimport com.google.android.gms.maps.model.Marker;\r\nimport com.google.android.gms.maps.model.MarkerOptions;\r\n\r\n\r\npublic class MapsActivity extends FragmentActivity implements OnMapReadyCallback {\r\n\r\n    private GoogleMap mMap;\r\n    LandmarkMapAdapter lma = new LandmarkMapAdapter();\r\n    private float GEOFENCE_RADIUS=200;\r\n    private double mLat, mLng, cLat, cLng;\r\n\r\n\r\n    // Location variables used to request permissions\r\n    private Location currentLocation;\r\n    private FusedLocationProviderClient locationClient;\r\n    private final int REQUEST_PERMISSION_LOCATION = 2;\r\n    private LocationCallback locationCallback;\r\n\r\n    // Location variable used to display results\r\n    //private LocationAddressResultReceiverTest addressResultReceiver;\r\n\r\n    private TextView userLocation;\r\n    private GeofencingClient geofencing;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_geofriend_map);\r\n        // Obtain the SupportMapFragment and get notified when the map is ready to be used.\r\n        SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()\r\n                .findFragmentById(R.id.map);\r\n        mapFragment.getMapAsync(this);\r\n\r\n        //Loads landmarks into the adapter instance\r\n        lma.loadLandmarks();\r\n\r\n//        userLocation = findViewById(R.id.landMarkTxt);\r\n\r\n        // ----- This is used to display current location information -----\r\n        locationClient = LocationServices.getFusedLocationProviderClient(this);\r\n        locationCallback = new LocationCallback() {\r\n            @Override\r\n            public void onLocationResult(LocationResult locationResult) {\r\n                currentLocation = locationResult.getLocations().get(0);\r\n                //getAddress();\r\n            }\r\n        };\r\n        // ----- This is used to display current location information -----\r\n\r\n        //create geofencing\r\n        geofencing = LocationServices.getGeofencingClient(this);\r\n\r\n    }\r\n\r\n    /**\r\n     * Manipulates the map once available.\r\n     * This callback is triggered when the map is ready to be used.\r\n     * This is where we can add markers or lines, add listeners or move the camera. In this case,\r\n     * we just add a marker near Sydney, Australia.\r\n     * If Google Play services is not installed on the device, the user will be prompted to install\r\n     * it inside the SupportMapFragment. This method will only be triggered once the user has\r\n     * installed Google Play services and returned to the app.\r\n     */\r\n    @Override\r\n    public void onMapReady(GoogleMap googleMap) {\r\n//         ----- Check the location permission status -----\r\n//         Example: If not already granted, request for location permission\r\n//        startLocationUpdates();\r\n\r\n        mMap = googleMap;\r\n\r\n        final String landmarkID = \"\";\r\n\r\n        if (!lma.landmarks.isEmpty()) {\r\n            for (int i = 0; i < lma.landmarks.size(); i++) {\r\n                mMap.addMarker(new MarkerOptions().position(lma.landmarks.get(i).getLocation()).title(lma.landmarks.get(i).getName()));\r\n                //Pull markers from database and put them into the map\r\n                addCircle(lma.landmarks.get(i).getLocation(),GEOFENCE_RADIUS);\r\n            }\r\n        }\r\n\r\n        //Moves camera to a park nearby my house.\r\n        mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(new LatLng(50.66107816, -120.2600196), 17.0f));\r\n\r\n        mMap.setOnMarkerClickListener(new GoogleMap.OnMarkerClickListener() {\r\n            @Override\r\n            public boolean onMarkerClick(Marker marker) {\r\n\r\n//                mLat = la.landmarks.get(Integer.parseInt(marker.getId().substring(1))).getLocation().latitude;\r\n//                mLng = la.landmarks.get(Integer.parseInt(marker.getId().substring(1))).getLocation().longitude;\r\n\r\n\r\n                int markerClick = Log.v(\"click\", \"Markerclick\");\r\n                Intent intent = new Intent(MapsActivity.this, LandmarkPopUpActivity.class);\r\n                intent.putExtra(\"landmarkID\", marker.getId().substring(1));\r\n                startActivity(intent);\r\n                return false;\r\n\r\n\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    // Permission to access users current location\r\n    private void startLocationUpdates() {\r\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) !=\r\n                PackageManager.PERMISSION_GRANTED) {\r\n            ActivityCompat.requestPermissions(this, new\r\n                            String[]{Manifest.permission.ACCESS_FINE_LOCATION},\r\n                    REQUEST_PERMISSION_LOCATION);\r\n        } else {\r\n            LocationRequest locationRequest = new LocationRequest();\r\n            locationRequest.setInterval(2000);\r\n            locationRequest.setFastestInterval(1000);\r\n            locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n            locationClient.requestLocationUpdates(locationRequest, locationCallback, null);\r\n        }\r\n    }\r\n\r\n    /*private void getAddress() {\r\n        if (!Geocoder.isPresent()) {\r\n            Toast.makeText(MapsActivity.this, \"Can't find current address, \",\r\n                    Toast.LENGTH_SHORT).show();\r\n            return;\r\n        }\r\n        Intent intent = new Intent(this,GetAddressIntentService.class);\r\n        intent.putExtra(\"add_receiver\", addressResultReceiver);\r\n        intent.putExtra(\"add_location\", currentLocation);\r\n        startService(intent);\r\n    } */\r\n\r\n    /*private class LocationAddressResultReceiverTest extends ResultReceiver implements com.geofriend.geofriend.LocationAddressResultReceiver {\r\n        LocationAddressResultReceiverTest(Handler handler) {\r\n            super(handler);\r\n        }\r\n\r\n        @Override\r\n        protected void onReceiveResult(int resultCode, Bundle resultData) {\r\n            if (resultCode == 0) {\r\n                Log.d(\"Address\", \"Location null retrying\");\r\n                getAddress();\r\n            }\r\n            if (resultCode == 1) {\r\n                Toast.makeText(MapsActivity.this, \"Address not found, \", Toast.LENGTH_SHORT).show();\r\n            }\r\n            String currentAdd = resultData.getString(\"address_result\");\r\n            showResults(currentAdd);\r\n        }\r\n\r\n        private void showResults(String currentAdd) {\r\n            userLocation.setText(currentAdd);\r\n        }\r\n    }*/\r\n\r\n    @Override\r\n    protected void onResume() {\r\n        super.onResume();\r\n        startLocationUpdates();\r\n    }\r\n\r\n    @Override\r\n    protected void onPause() {\r\n        super.onPause();\r\n        locationClient.removeLocationUpdates(locationCallback);\r\n    }\r\n/*\r\n    private void enableUserLocation() {\r\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n            mMap.setMyLocationEnabled(true);\r\n        } else {\r\n            //ask for permission\r\n            if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_FINE_LOCATION)) {\r\n                //explain\r\n                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, REQUEST_PERMISSION_LOCATION);\r\n            } else {\r\n                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, REQUEST_PERMISSION_LOCATION);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        if (requestCode == REQUEST_PERMISSION_LOCATION) {\r\n            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n                    // TODO: Consider calling\r\n                    //    ActivityCompat#requestPermissions\r\n                    // here to request the missing permissions, and then overriding\r\n                    //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\r\n                    //                                          int[] grantResults)\r\n                    // to handle the case where the user grants the permission. See the documentation\r\n                    // for ActivityCompat#requestPermissions for more details.\r\n                    return;\r\n                }\r\n                mMap.setMyLocationEnabled(true);\r\n            }else{\r\n\r\n            }\r\n        }\r\n    }*/\r\n    private void addCircle(LatLng latLng,float radius){\r\n        CircleOptions circleOptions=new CircleOptions();\r\n        circleOptions.center(latLng);\r\n        circleOptions.radius(radius);\r\n        circleOptions.strokeColor(Color.argb(255,255,0,0));\r\n        circleOptions.fillColor(Color.argb(64,255,0,0));\r\n        circleOptions.strokeWidth(4);\r\n        mMap.addCircle(circleOptions);\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/geofriend/geofriend/MapsActivity.java	(revision 08b08703bf179a5d47f20329c090f7eadc5ada2f)
+++ app/src/main/java/com/geofriend/geofriend/MapsActivity.java	(date 1605165794587)
@@ -1,21 +1,39 @@
 package com.geofriend.geofriend;
 
 import android.Manifest;
+import android.app.PendingIntent;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.graphics.Color;
 import android.location.Location;
+import android.os.Build;
 import android.os.Bundle;
 import android.util.Log;
 import android.widget.TextView;
+import android.widget.Toast;
 
 import androidx.annotation.NonNull;
 import androidx.core.app.ActivityCompat;
 import androidx.core.content.ContextCompat;
 import androidx.fragment.app.FragmentActivity;
 
+import com.google.android.gms.location.Geofence;
+import com.google.android.gms.location.GeofencingClient;
+import com.google.android.gms.location.GeofencingRequest;
+import com.google.android.gms.location.LocationServices;
+import com.google.android.gms.maps.CameraUpdateFactory;
+import com.google.android.gms.maps.GoogleMap;
+import com.google.android.gms.maps.OnMapReadyCallback;
+import com.google.android.gms.maps.SupportMapFragment;
+import com.google.android.gms.maps.model.CircleOptions;
+import com.google.android.gms.maps.model.LatLng;
+import com.google.android.gms.maps.model.MarkerOptions;
+import com.google.android.gms.tasks.OnFailureListener;
+import com.google.android.gms.tasks.OnSuccessListener;
 import com.google.android.gms.location.FusedLocationProviderClient;
+import com.google.android.gms.location.Geofence;
 import com.google.android.gms.location.GeofencingClient;
+import com.google.android.gms.location.GeofencingRequest;
 import com.google.android.gms.location.LocationCallback;
 import com.google.android.gms.location.LocationRequest;
 import com.google.android.gms.location.LocationResult;
@@ -28,27 +46,32 @@
 import com.google.android.gms.maps.model.LatLng;
 import com.google.android.gms.maps.model.Marker;
 import com.google.android.gms.maps.model.MarkerOptions;
+import com.google.android.gms.tasks.OnFailureListener;
+import com.google.android.gms.tasks.OnSuccessListener;
 
 
-public class MapsActivity extends FragmentActivity implements OnMapReadyCallback {
+public class MapsActivity extends FragmentActivity implements OnMapReadyCallback  {
 
+    private static final String TAG = "MapActivity";
     private GoogleMap mMap;
     LandmarkMapAdapter lma = new LandmarkMapAdapter();
-    private float GEOFENCE_RADIUS=200;
+    private float GEOFENCE_RADIUS = 200;
     private double mLat, mLng, cLat, cLng;
-
+    private String GEOFENCE_ID = "someID0";
 
     // Location variables used to request permissions
     private Location currentLocation;
     private FusedLocationProviderClient locationClient;
     private final int REQUEST_PERMISSION_LOCATION = 2;
+    private final int BACKGROUND_LOCATION_ACCESS_REQUEST_CODE = 10002;
     private LocationCallback locationCallback;
 
     // Location variable used to display results
     //private LocationAddressResultReceiverTest addressResultReceiver;
 
     private TextView userLocation;
-    private GeofencingClient geofencing;
+    private GeofencingClient geofencingClient;
+    private GeofenceHelper geofenceHelper;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -76,7 +99,7 @@
         // ----- This is used to display current location information -----
 
         //create geofencing
-        geofencing = LocationServices.getGeofencingClient(this);
+        geofencingClient = LocationServices.getGeofencingClient(this);
 
     }
 
@@ -98,15 +121,39 @@
         mMap = googleMap;
 
         final String landmarkID = "";
-
+        enableUserLocation();
         if (!lma.landmarks.isEmpty()) {
             for (int i = 0; i < lma.landmarks.size(); i++) {
                 mMap.addMarker(new MarkerOptions().position(lma.landmarks.get(i).getLocation()).title(lma.landmarks.get(i).getName()));
                 //Pull markers from database and put them into the map
-                addCircle(lma.landmarks.get(i).getLocation(),GEOFENCE_RADIUS);
+                addCircle(lma.landmarks.get(i).getLocation(), GEOFENCE_RADIUS);
+
+            }
+
+            //can only add one geofencing each
+            LatLng latLng = new LatLng(37.42, -122.084);
+            if (Build.VERSION.SDK_INT >= 29) {
+                //We need background permission
+                if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION) == PackageManager.PERMISSION_GRANTED) {
+                    addGeofence(latLng, GEOFENCE_RADIUS);
+                } else {
+                    if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION)) {
+                        //We show a dialog and ask for permission
+                        ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.ACCESS_BACKGROUND_LOCATION}, BACKGROUND_LOCATION_ACCESS_REQUEST_CODE);
+                    } else {
+                        ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.ACCESS_BACKGROUND_LOCATION}, BACKGROUND_LOCATION_ACCESS_REQUEST_CODE);
+                    }
+                }
+
+            } else {
+                addGeofence(latLng, GEOFENCE_RADIUS);
             }
+          // mMap.setOnMapLongClickListener(this);
+
+
         }
 
+        //
         //Moves camera to a park nearby my house.
         mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(new LatLng(50.66107816, -120.2600196), 17.0f));
 
@@ -146,6 +193,53 @@
         }
     }
 
+    @Override
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
+        if (requestCode == REQUEST_PERMISSION_LOCATION) {
+            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+                //We have the permission
+                if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
+                    // TODO: Consider calling
+                    //    ActivityCompat#requestPermissions
+                    // here to request the missing permissions, and then overriding
+                    //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
+                    //                                          int[] grantResults)
+                    // to handle the case where the user grants the permission. See the documentation
+                    // for ActivityCompat#requestPermissions for more details.
+                    return;
+                }
+                mMap.setMyLocationEnabled(true);
+            } else {
+                //We do not have the permission..
+
+            }
+        }
+
+        if (requestCode == BACKGROUND_LOCATION_ACCESS_REQUEST_CODE) {
+            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+                //We have the permission
+                Toast.makeText(this, "You can add geofences...", Toast.LENGTH_SHORT).show();
+            } else {
+                //We do not have the permission..
+                Toast.makeText(this, "Background location access is neccessary for geofences to trigger...", Toast.LENGTH_SHORT).show();
+            }
+        }
+    }
+
+    private void enableUserLocation() {
+        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
+            mMap.setMyLocationEnabled(true);
+        } else {
+            //Ask for permission
+            if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_FINE_LOCATION)) {
+                //We need to show user a dialog for displaying why the permission is needed and then ask for the permission...
+                ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.ACCESS_FINE_LOCATION}, REQUEST_PERMISSION_LOCATION);
+            } else {
+                ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.ACCESS_FINE_LOCATION}, REQUEST_PERMISSION_LOCATION);
+            }
+        }
+    }
+
     /*private void getAddress() {
         if (!Geocoder.isPresent()) {
             Toast.makeText(MapsActivity.this, "Can't find current address, ",
@@ -192,52 +286,66 @@
         super.onPause();
         locationClient.removeLocationUpdates(locationCallback);
     }
-/*
-    private void enableUserLocation() {
-        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
-            mMap.setMyLocationEnabled(true);
-        } else {
-            //ask for permission
-            if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_FINE_LOCATION)) {
-                //explain
-                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, REQUEST_PERMISSION_LOCATION);
-            } else {
-                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, REQUEST_PERMISSION_LOCATION);
 
-            }
-        }
+
+    private void addCircle(LatLng latLng, float radius) {
+        CircleOptions circleOptions = new CircleOptions();
+        circleOptions.center(latLng);
+        circleOptions.radius(radius);
+        circleOptions.strokeColor(Color.argb(255, 255, 0, 0));
+        circleOptions.fillColor(Color.argb(64, 255, 0, 0));
+        circleOptions.strokeWidth(4);
+        mMap.addCircle(circleOptions);
     }
 
-    @Override
-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-        if (requestCode == REQUEST_PERMISSION_LOCATION) {
-            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-                if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
-                    // TODO: Consider calling
-                    //    ActivityCompat#requestPermissions
-                    // here to request the missing permissions, and then overriding
-                    //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
-                    //                                          int[] grantResults)
-                    // to handle the case where the user grants the permission. See the documentation
-                    // for ActivityCompat#requestPermissions for more details.
-                    return;
-                }
-                mMap.setMyLocationEnabled(true);
-            }else{
-
-            }
-        }
-    }*/
-    private void addCircle(LatLng latLng,float radius){
-        CircleOptions circleOptions=new CircleOptions();
-        circleOptions.center(latLng);
-        circleOptions.radius(radius);
-        circleOptions.strokeColor(Color.argb(255,255,0,0));
-        circleOptions.fillColor(Color.argb(64,255,0,0));
-        circleOptions.strokeWidth(4);
-        mMap.addCircle(circleOptions);
+
+    private void addGeofence(LatLng latLng, float radius) {
+
+        Geofence geofence = geofenceHelper.getGeofence(GEOFENCE_ID, latLng, radius, Geofence.GEOFENCE_TRANSITION_ENTER);
+        GeofencingRequest geofencingRequest = geofenceHelper.getGeofencingRequest(geofence);
+        PendingIntent pendingIntent = geofenceHelper.getPendingIntent();
+
+        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
+            // TODO: Consider calling
+            //    ActivityCompat#requestPermissions
+            // here to request the missing permissions, and then overriding
+            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
+            //                                          int[] grantResults)
+            // to handle the case where the user grants the permission. See the documentation
+            // for ActivityCompat#requestPermissions for more details.
+            return;
+        }
+        geofencingClient.addGeofences(geofencingRequest, pendingIntent)
+                .addOnSuccessListener(new OnSuccessListener<Void>() {
+                    @Override
+                    public void onSuccess(Void aVoid) {
+                        Log.d(TAG, "onSuccess: Geofence Added...");
+                    }
+                })
+                .addOnFailureListener(new OnFailureListener() {
+                    @Override
+                    public void onFailure(@NonNull Exception e) {
+                        String errorMessage = geofenceHelper.getErrorString(e);
+                        Log.d(TAG, "onFailure: " + errorMessage);
+                    }
+                });
     }
 
+    /*@Override
+    public void onMapLongClick(LatLng latLng) {
+
+
+    }
 
+    private void handleMapLongClick(LatLng latLng) {
+        mMap.clear();
+        addMarker(latLng);
+        addCircle(latLng, GEOFENCE_RADIUS);
+        addGeofence(latLng, GEOFENCE_RADIUS);
+    }
+*/
+    private void addMarker(LatLng latLng) {
+        MarkerOptions markerOptions = new MarkerOptions().position(latLng);
+        mMap.addMarker(markerOptions);
+    }
 }
\ No newline at end of file
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><resources>\r\n    <string name=\"app_name\">GeoFriend</string>\r\n\r\n    <string name=\"label_emailpassword\">Email/Password Authentication</string>\r\n    <string name=\"desc_emailpassword\">Use an email and password to authenticate with Firebase.</string>\r\n\r\n    <string name=\"hint_user_id\">User ID</string>\r\n    <string name=\"get_custom_token\">Get Token</string>\r\n    <string name=\"sign_in\">Sign In</string>\r\n    <string name=\"create_account\">Create Account</string>\r\n    <string name=\"send_link\">Send Link</string>\r\n    <string name=\"sign_out\">Sign Out</string>\r\n    <string name=\"explore\">Explore</string>\r\n    <string name=\"disconnect\">Disconnect</string>\r\n    <string name=\"loading\">Loading…</string>\r\n    <string name=\"custom_token\">Custom Token</string>\r\n    <string name=\"signed_in\">Signed In</string>\r\n    <string name=\"signed_out\">Signed Out</string>\r\n    <string name=\"token_null\">Token: null</string>\r\n    <string name=\"hint_email\">Email</string>\r\n    <string name=\"hint_password\">Password</string>\r\n    <string name=\"desc_firebase_lockup\">Firebase logo and name</string>\r\n    <string name=\"auth_failed\">Authentication failed</string>\r\n    <string name=\"start_phone_auth\">Start</string>\r\n    <string name=\"verify_phone_auth\">Verify</string>\r\n    <string name=\"resend_phone_auth\">Resend</string>\r\n    <string name=\"hint_phone_number\">Phone Number</string>\r\n    <string name=\"hint_verification_code\">Verification Code</string>\r\n    <string name=\"status_code_sent\">Code Sent</string>\r\n    <string name=\"status_verification_failed\">Verification failed</string>\r\n    <string name=\"status_verification_succeeded\">Verification succeeded</string>\r\n    <string name=\"status_sign_in_failed\">Sign-in failed</string>\r\n    <string name=\"instant_validation\">(instant validation)</string>\r\n\r\n    <string name=\"firebase_status_fmt\">Firebase UID: %s</string>\r\n    <string name=\"firebase_user_management\">Firebase User Management</string>\r\n    <string name=\"emailpassword_status_fmt\">Email User: %1$s (verified: %2$b)</string>\r\n    <string name=\"geofriend_title_text\">GeoFriend</string>\r\n\r\n    <string name=\"passwordless_status_fmt\">Email User: %1$s (verified: %2$b)</string>\r\n    <string name=\"passwordless_title_text\">Passwordless Sign In</string>\r\n    <string name=\"status_email_not_sent\">Send link to your email to get started.</string>\r\n    <string name=\"status_email_sent\">Link sent, check your email to continue.</string>\r\n    <string name=\"status_link_found\">Link received, enter email to sign in.</string>\r\n\r\n    <string name=\"phone_title_text\">Phone Number</string>\r\n\r\n    <string name=\"twitter_status_fmt\">Twitter User: %s</string>\r\n    <string name=\"twitter_title_text\">Twitter Login</string>\r\n\r\n    <string name=\"firebaseui_status_fmt\">Firebase User: %s</string>\r\n    <string name=\"firebaseui_title_text\">FirebaseUI Auth</string>\r\n\r\n    <string name=\"generic_title_text\">OAuth Sign In</string>\r\n    <string name=\"generic_signin_fmt\">Sign In with %s</string>\r\n    <string name=\"generic_status_fmt\">User: %s (%s)</string>\r\n    <string name=\"generic_label_provider\">Provider:</string>\r\n\r\n    <string name=\"id_fmt\">User ID: %s</string>\r\n    <string name=\"email_fmt\">Email: %s</string>\r\n\r\n    <string name=\"enroll_mfa\">Enroll MFA</string>\r\n    <string name=\"unenroll_mfa\">Unenroll MFA</string>\r\n    <string name=\"reload\">Reload</string>\r\n\r\n    <string name=\"custom_auth_signin_status_user\">User ID: %s</string>\r\n    <string name=\"custom_auth_signin_status_failed\">Error: sign in failed</string>\r\n\r\n    <string name=\"error_sign_in_failed\">Sign in failed, see logs for details.</string>\r\n    <string name=\"multi_factor_signed_out\">You are not signed in. To use this sample, first navigate to the Email/Password example to sign in and then return here to enroll in multi-factor auth.</string>\r\n    <string name=\"landing_page\">Landing Page</string>\r\n    <string name=\"title_activity_maps\">Map</string>\r\n    <string name=\"location\">Loading Location...</string>\r\n    <string name=\"get_location\">Get Location</string>\r\n    <string name=\"geofence\">Geofence</string>\r\n    <string name=\"title_activity_google_maps\">Map</string>\r\n    <string name=\"get_coordinates\">GPS Coordinates</string>\r\n    <string name=\"gps_location\">GPS Location:</string>\r\n    <string name=\"button\">Button</string>\r\n    <string name=\"name\">Name:</string>\r\n    <string name=\"longtiude\">Longtiude:</string>\r\n    <string name=\"loading_current_location\">Loading Current Location...</string>\r\n    <string name=\"show_exact_gps_coordinates\">GPS Coordinates:</string>\r\n    <string name=\"current_location_bttn_txt\">Current Location</string>\r\n\r\n</resources>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/strings.xml	(revision 08b08703bf179a5d47f20329c090f7eadc5ada2f)
+++ app/src/main/res/values/strings.xml	(date 1605161961120)
@@ -82,5 +82,6 @@
     <string name="loading_current_location">Loading Current Location...</string>
     <string name="show_exact_gps_coordinates">GPS Coordinates:</string>
     <string name="current_location_bttn_txt">Current Location</string>
+    <string name="title_activity_maps2">Map</string>
 
 </resources>
Index: app/src/main/res/layout/activity_maps.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_maps.xml	(date 1605161961360)
+++ app/src/main/res/layout/activity_maps.xml	(date 1605161961360)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<fragment xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:map="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/map"
+    android:name="com.google.android.gms.maps.SupportMapFragment"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context=".MapsActivity2" />
\ No newline at end of file
